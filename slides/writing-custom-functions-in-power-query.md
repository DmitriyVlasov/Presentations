- title : Writing Custom Functions in Power Query
- description : Разработка пользовательских функций в Power Query (Черновик)
- author : Dmitriy Vlasov
- theme : night
- transition : default

## Разработка пользовательских функций в Power Query

[Дмитрий Власов](http://DmitriyVlasov.ru),

Ведущий ERP разработчик в Awara IT Solutions

Первая встреча [группы пользователей Microsoft Power BI в Санкт-Петербурге](https://www.pbiusergroup.com/communities/community-home?CommunityKey=f6f83caa-78fb-4a11-92fb-522457064f77)

23 августа 2017

---

## Содержание

---

## Содержание

1. Зачем писать свои функции?
1. Основные компоненты языка Power Query
1. Базовая библиотека языка Power Query
1. Средства разработки
1. Ссылки на источники и дополнительные материалы

' Рекомендации по плану от Максима Зеленского:
' + 1. М - язык функциональный (почти всё на встроенных функциях).
' + 2. Имена, выражения, типы
' + 3. Функция - выражение, тип данных, и отличие от типа результата вычисленной функции.
' 4. Когда нужны функции. 
' 5. Встроенные итераторы и each keyword
' 6. Передача аргументов между вложенными функциями
' 7. Примеры inline функций и именованных функций.


***

## Зачем писать свои функции?

***

## Основные компоненты языка Power Query

---

## Основные компоненты языка Power Query
* Обзор
* Базовые типы данных
* Синтаксис

---

### Обзор

#### Формула языка

Язык программирования Power Query:

* **[Pure](https://ru.wikipedia.org/wiki/Чистота_языка_программирования)** - чистый,
* **[Dynamically typed](https://ru.wikipedia.org/wiki/Динамическая_типизация)** - динамически типизированный,
* **[Higer-order](https://ru.wikipedia.org/wiki/Функция_высшего_порядка)** - поддерживает функции высшего порядка,
* **[Partially lazy](https://ru.wikipedia.org/wiki/Ленивые_вычисления)** - частично ленивый,
* **[Functional](https://ru.wikipedia.org/wiki/Функциональное_программирование)** - функциональный.

' Чистый - означает, Побочные эффекты отсутствуют.
' Динамически типизированный - означает, что типы выражений определяются в момент исполнения.
' Функции высшего порядка - это функции использующие в качестве параметра другие функции. Подобные ситуации мы будем встречать далее на каждом шагу при работе с языком Power Query.
' Ленивый - означает, что вычисления происходят так поздно на сколько это возможно. Ленивость языка программирования позволяет делать такие вещи как бесконечные списки, а значит как следствие например удобно поддерживать подключения к базам данных и сервисам по требованию. Или делать сложные вычисления только в тот момент когда это понадобиться.
' Функциональный - означает, что процесс вычисления трактуется как вычисление значений функций в математическом понимании последних.

--- 

### Обзор

#### Определение основных элементов языка

* **Идентификатор** _(Identifier)_ это имя. 
* **Выражение** _(Expression)_ это формула вычисления. Выражения имеют имя.
* **Значение** _(Value)_  это результат вычисления выражения. Значение имеет тип.
* **Тип** _(Type)_ это особый вид значения. Тип может содержать метаданные.
* **Функция** _(Function)_ это особый вид значения. Обеспечивает основу стандартной библиотеки и позволяет создавать собственные функции.
* **Запрос** Вычисляет выражения и возвращает значение.

' Метаданные это просто запись дополнительной информации, которую прикреплять к значению и извлекать из значения.
' Например письмо. Содержимое письма это значение, а отправитель, получатель, индекс получателя это метаданные.

---

### Обзор

#### Примеры основных элементов языка

* Безымянное значение

```pq
42
```

* Именованное значение

```pq
А = 42
```

* Именованное выражение с формулой, при вычислении возвращающей значение

```pq
B = 6 * 7
```

---

### Обзор

#### Примеры основных элементов языка

* Безымянная функция

' Или как говорят анонимная функция.

```pq
(x) => x * 1.18
```

* Именованная функция это выражение с формулой при вычислении возвращающей функцию

```pq
sumVat = (x) => x * 1.18
```

* Именованное значение с прикрепленными метаданными

```pq
Vat = 1.18 meta [Description = "Базовая ставка налога в РФ в 2017 году."]
```

---

### Базовые типы данных

#### Примитивные типы данных

| Тип | Пример | |
| --- | --- | --- |
| logical | `true` | `false` |
| text | `"Hello"` | `"Привет"` |
| number | `-42` | `3.14` |

--- 

### Базовые типы данных

#### Типы даты времени

| Тип | Пример |
| --- | --- |
| time | `#time(21,35,00)` |
| date | `#date(2017,08,23)` |
| datetime | `#datetime(2017,08,23 21,35,00)` |
| datetimezone | `#datetimetzone(2017,08,23 21,35,00 09,00)` |
| duration | `#duration(0,1,30,0)` |

' Обратите внимание, что в примерах фактически происходит создание значений с помощью встроенных в язык функций начинающих свое имя с решетки.

---

### Базовые типы данных

#### Структуры данных

| Тип | Пример |
| --- | --- |
| list | `{1, 2, 3}` |
| record | `[FirstName = "Олег", LastName = "Попов"]` |
| table | `#table( { "Группа", "Резус" }, { {1, "+"}, {2, "-"} } )` |

' Power Query поддерживает три базовые структуры данных это списки (list), записи (record) и таблицы (table). Таблицы это списки содержащие в качестве значения записи.

---

### Базовые типы данных

#### Особые типы данных

| Тип | Пример | Примечание |
| --- | --- | --- |
| null | `null` | Отсутствие значения. |
| any | | Любой тип данных |
| binary | `#binary("AQID")` | Двоичные данные |
| function | `(x) => x * 1.18` | Функциональный тип данных |
| type | `type { number }` | Тип данных описывающий тип ;-). |

---

### Базовые типы данных

#### Списки

* Список простых значений

```pq
{ 1, 2, 3 } // Список из трех значений
```

* Перечисление

```pq
{1,3,5..10} // Значения 1,3 и от 5 до 10 включительно.
```

```pq
{ "а" .. "я" } // Алфавит: а, б, в, г .. я.
```

* Смешанный список

```pq
{ true, 42, 3.14, "Привет" } // Значения истина, числа и строка
```

' Список это упорядоченная последовательность значений. Нумерация начинается от нуля.
' В следствие ленивости языка в Power Query можно создавать списки бесконечные списки.
' Перечень значений списка заключена в фигурные скобки.
' Список может содержать в своем перечне значения любых типов.

---

### Базовые типы данных

#### Записи

* Простая запись

```pq
 [ Йоулупукки = "Финляндия", Дед Мороз = "Россия" ]
```

* Запись содержащая поля отдельными значениями и списком 

```pq
 [ Йоулупукки = "Финляндия",
   Дед Мороз = "Россия" ,
   Санта Клаус = {"Германия", "США", "Канада"},
  #"Одзи-сан" = "Япония"
```

' Запись это не упорядоченный набор полей.
' Каждое поле имеет пару имя и значение.
' Имя должно быть уникальным внутри записи.
' Запись может содержать поля со значениями любых типов.
' Обратите внимание как записано имя деда мороза в Японии.
' Пришлось указать так называемую литеральную форму записи.
' Запись позволяет иметь простые имена, содержащие пробелы в качестве идентификатора, но если появляются другие символы их нужно записывать в специальной форме. 

' Оставить на будущее: 
'  getHoliday = (SantaName, record) => 
'    SantaName & " символ нового года в стране " & 
'    Record.Field(record, SantaName) & "." ]

---

### Базовые типы данных

#### Таблица

* Символы нового года в разных странах

```pq
  #table( 
    {"Имя", "Страна"}
    {
      {"Дед мороз", "Россия"}
      {"Санта-Клаус", "США"}
      {"Санта-Клаус", "Германия"}
      {"Санта-Клаус", "Канада"}
      {"Одзи-сан", "Япония"}
    }
  )
```

' Таблица это множество значений собранных столбцы и строки.
' Самая простая базовая функция создающая таблицу из первый параметр список заголовков, второй список строк.
' В базовой библиотеке есть ряд удобных функций по созданию списков. 

---

### Синтаксис

#### Комментарии

```pq
/*Многострочные комментарии*/

// Однострочный комментарий
```

' Вложенные комментарии не поддерживаются.

---
 
### Синтаксис

#### Простейшие выражения

```pq
42 // Значение
```

```pq
6 * 7 // Произведение двух чисел
```

```pq
#date // простейшая функция создания даты
```

```pq
#date(2017,08,23) // Значение даты
```

---

### Синтаксис

#### Выражение let

```pq
let           // Обязательное ключевое слово.
    A = 1,    // Далее с новой строки одно
    B = 2,    // или несколько выражений
    C = A + B // разделенных запятыми.
in            // Обязательное ключевое слово.
  C           // Возвращаемый результат, вычисляется перед возвратом.
```

---

### Синтаксис

#### Имена выражений

```pq
let
  // Имя выражения только на английском языке без пробелов:
  NumberValue = 42,

  // Имя выражения в форме человеко-читаемого предложения 
  // на любом языке любой длины:
  #"Ответ на главный вопрос жизни, вселенной и всего такого" = NumberValue,

in
  #"Ответ на главный вопрос жизни, вселенной и всего такого"

```

---

### Синтаксис

#### Условное выражение

' Например, давайте напишем выражение требующее принятие решения:
' Если ткущий ответ 42 то следующего ответа ждать бесконечно долго, а иначе ответа не будет.
' Обратите внимание, условное выражение написано без скобок.
' Так как if then else это тоже выражение то обе ветки then и else обязательные.

```pq
let 
  #"Ответ на главный вопрос жизни, вселенной и всего такого" = 42,
  currentAnswer = 10,

  nextAnswerDelay = 
      if currentAnswer = 42
    then #infinity // Бесконечность
    else null      // Пусто
in
  nextAnswerDelay
```

---

### Синтаксис

#### Условное выражение

```pq
let
  currentAnswer = 10,
  nextAnswerDelay = 
    if currentAnswer = 42 or 
       currentAnswer = 0 or
       currentAnswer = null
    then #infinity
    else null

in
  nextAnswerDelay
```

' В общем случае, если вы описываете в условии несколько последовательных условий, то скобки ставить не нужно,
' Но если вы явно хотите, можете указать скобками приоритет вычисления тех или иных условий.
' Особенно если идет комбинация or и and в одном условии if.  

---

### Синтаксис

#### Пример функции

' Более интересной возможностью будет возможность повторно использовать созданное выражение.
' Давайте обернем его в функцию и вернем для повторного использования.

```pq
let 
  #"Ответ на главный вопрос жизни, вселенной и всего такого" = 42,
  getNextAnswerDelay = (currentAnswer) => 
    if currentAnswer = #"Ответ на главный вопрос жизни, вселенной и всего такого"
    then #infinity
    else null
in
  getNextAnswerDelay
```

---

### Синтаксис

#### Пример функции (Подробности)

' Более интересной возможностью будет возможность повторно использовать созданное выражение.
' Давайте обернем его в функцию и вернем для повторного использования.

```pq
let 
  #"Ответ на главный вопрос жизни, вселенной и всего такого" = 42,
  getNextAnswerDelay = (currentAnswer) => 
    if currentAnswer = #"Ответ на главный вопрос жизни, вселенной и всего такого"
    then #infinity
    else null
in
  getNextAnswerDelay
```

---

### Метаданные

* `#sections` - Возвращает в записи имена и типы возвращаемого значения для всех запросов из текущего документа Power BI.
* `#shared` - Возвращает в записи все имена запросы, функции и типы из текущего документа Power BI.

***

## Базовая библиотека языка Power Query

***

## Средства разработки

*** 

## Ссылки на источники и дополнительные материалы